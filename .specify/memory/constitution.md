<!--
버전 변경: 1.0.0 → 1.0.1
수정된 원칙: 없음 (언어를 영어에서 한글로 변경)
추가된 섹션: 없음
제거된 섹션: 없음
업데이트 필요한 템플릿:
  ✅ .specify/templates/plan-template.md - Constitution Check 섹션 정렬됨
  ✅ .specify/templates/spec-template.md - 변경 불필요 (기술 중립적)
  ✅ .specify/templates/tasks-template.md - 변경 불필요 (구조 중립적)
후속 작업: 없음
-->

# Astro 개발 블로그 헌법

## 핵심 원칙

### I. 성능 우선 (Performance First)

블로그는 모든 지표에서 Lighthouse 점수 95+ 이상을 달성해야 합니다. 이는 다음을 통해 달성됩니다:

- **Astro Islands 아키텍처**: 선택적 hydration 사용. 기본적으로 0 bytes의 JavaScript 전송.
- **빌드타임 vs 런타임**: 모든 콘텐츠를 빌드 시점에 사전 렌더링. 서버 사이드 렌더링(SSR) 사용 금지.
- **최소한의 클라이언트 JavaScript**: 절대적으로 필요할 때만 인터랙티브 컴포넌트를 hydrate.

**근거**: 개발자 블로그는 콘텐츠가 핵심입니다. 독자는 풍부한 상호작용보다 빠른 로딩 속도와 낮은 데이터 사용량을 중요하게 생각합니다. 성능은 최적화가 아니라 핵심 기능입니다.

### II. 컴포넌트 분류 규칙 (Component Classification Rule)

컴포넌트 기술 선택은 단 하나의 판단 기준을 따라야 합니다: "이 컴포넌트에 상태나 이벤트가 필요한가?"

- **필요함** → `.tsx` 사용 (클라이언트 사이드 JavaScript가 있는 React 컴포넌트)
- **필요 없음** → `.astro` 사용 (클라이언트로 전송되는 JavaScript 0 bytes)

이 규칙은 예외 없이 모든 컴포넌트에 적용됩니다. 확실하지 않으면 `.astro`로 시작하고, 상호작용이 실제로 필요함이 입증된 경우에만 `.tsx`로 전환합니다.

**근거**: 조기 상호작용 구현은 현대 웹 애플리케이션에서 JavaScript 비대화의 주요 원인입니다. 단일 판단 규칙은 과도한 엔지니어링을 방지하고 성능 우선 원칙을 유지합니다.

### III. 빌드타임 우선 처리 (Build-Time Over Runtime)

가능한 한 모든 처리는 빌드 시점에 이루어져야 합니다:

- **코드 하이라이팅**: Shiki 사용 (빌드타임 문법 강조), 런타임 하이라이터 사용 절대 금지
- **댓글**: Giscus를 `<script>` 태그로 사용 (React 래퍼 불필요)
- **콘텐츠**: MDX 사용 (빌드 시점에 처리됨)
- **이미지 최적화**: 빌드 중 이미지 처리 및 최적화
- **데이터 페칭**: 가능한 경우 빌드 시점에 데이터 가져오기 및 캐싱

**근거**: 빌드타임 처리는 계산 비용을 사용자 기기에서 빌드 파이프라인으로 전환하여 성능을 개선하고 클라이언트 사이드 복잡도를 줄입니다.

### IV. 지연 로딩 및 코드 스플리팅 (Lazy Loading & Code Splitting)

중요하지 않은 모든 리소스에 대해 지연 로딩과 코드 스플리팅을 구현해야 합니다:

- **컴포넌트 스플리팅**: `client:load`, `client:visible`, `client:idle` 디렉티브를 사용하여 필요할 때만 React 컴포넌트 로드
- **이미지 지연 로딩**: 네이티브 lazy loading과 Astro의 이미지 최적화 사용
- **라우트 기반 스플리팅**: Astro의 페이지별 자동 코드 스플리팅

**근거**: 사용자는 현재 페이지 뷰에 필요한 코드만 다운로드해야 하며, 초기 로딩 시간과 데이터 전송을 최소화해야 합니다.

### V. TypeScript 타입 안정성 (TypeScript Type Safety)

모든 컴포넌트, 유틸리티, 데이터 구조에 대해 TypeScript 타입이 명확하게 정의되어야 합니다:

- **`any` 타입 금지**: 적절한 타입 정의 또는 타입 가드와 함께 `unknown` 사용
- **컴포넌트 props**: 명시적인 prop 인터페이스 정의
- **API 계약**: 모든 데이터 페칭 및 외부 통합에 타입 지정
- **공유 타입**: 공통 타입을 전용 타입 정의 파일로 추출

**근거**: 타입 안정성은 빌드 시점에 오류를 포착하고, 코드 유지보수성을 향상시키며, 자동완성과 인라인 문서를 통해 더 나은 개발자 경험을 제공합니다.

### VI. 데이터 페칭 및 캐싱 (Data Fetching & Caching)

동적 데이터 요구사항의 경우 React Query를 사용하여 효율적인 데이터 관리를 수행합니다:

- **서버 사이드 페칭**: 가능한 경우 빌드 시점에 Astro 컴포넌트에서 데이터 가져오기
- **클라이언트 사이드 페칭**: 적절한 캐싱 전략으로 동적 클라이언트 사이드 데이터에 React Query 사용
- **캐시 무효화**: 명확한 캐시 무효화 규칙 정의
- **로딩 상태**: 모든 비동기 작업에 적절한 로딩 및 에러 상태 제공

**근거**: 적절한 데이터 페칭 패턴은 중복 요청을 방지하고, 체감 성능을 개선하며, 일관된 사용자 경험을 제공합니다.

## 기술 제약사항

### 승인된 기술 스택

- **프레임워크**: Astro 5.x (필수)
- **스타일링**: TailwindCSS 4.x만 사용 (다른 CSS 프레임워크 금지)
- **댓글**: Giscus (GitHub Discussions 기반 댓글)
- **코드 품질**: Biome (린팅 및 포매팅)
- **컴포넌트 개발**: Storybook (컴포넌트 문서화 및 테스트)
- **인터랙티브 컴포넌트**: React (컴포넌트 분류 규칙에 따라 필요한 경우만)

### 금지된 기술

다음은 명시적으로 금지됩니다:

- **서버 사이드 렌더링(SSR)**: 정적 생성만 허용
- **자체 댓글 시스템**: Giscus 사용, 커스텀 댓글 백엔드 구축 금지
- **상태 관리 라이브러리**: Redux, MobX, Zustand 등 금지. React hooks 또는 React Query만 사용
- **여러 CSS 프레임워크 혼용**: TailwindCSS와 Bootstrap, Material-UI 등 혼용 금지
- **런타임 코드 하이라이팅**: 클라이언트 사이드에서 Prism.js, Highlight.js 금지

**근거**: 이러한 제약사항은 범위 확대를 방지하고, 번들 크기를 줄이며, 성능 목표를 유지하고, 코드베이스를 집중적이고 유지보수 가능하게 유지합니다.

## 개발 워크플로우

### 코드 품질 게이트

모든 커밋 전에:

1. **Biome 검사 통과 필수**: 린팅 및 포매팅 오류는 차단 사유
2. **TypeScript 컴파일 성공 필수**: 타입 오류 허용 안 됨
3. **빌드 완료 필수**: `astro build`가 오류 없이 성공해야 함
4. **Lighthouse 목표**: 주요 경로가 95+ 점수를 충족하는지 테스트

### 컴포넌트 개발

1. **Storybook으로 시작**: 컴포넌트를 격리된 환경에서 개발
2. **분류 규칙 적용**: 상태/이벤트 필요 여부에 따라 `.astro` 또는 `.tsx` 선택
3. **타입 먼저 정의**: 구현 전에 TypeScript 인터페이스 작성
4. **컨텍스트에서 테스트**: 실제 페이지에 통합하고 성능 영향 확인

### 성능 검증

- **컴포넌트별 영향**: 인터랙티브 컴포넌트가 추가될 때마다 번들 크기 변화 모니터링
- **정기적인 감사**: 주요 페이지에서 정기적으로 Lighthouse 실행
- **빌드타임 지표**: 빌드 시간과 정적 출력 크기 추적

## 거버넌스

### 개정 절차

1. **제안**: 근거와 함께 변경 제안 문서화
2. **영향 분석**: 기존 코드베이스 및 성능 목표에 대한 영향 평가
3. **승인**: 핵심 원칙 변경은 명시적인 승인 필요
4. **마이그레이션**: 기존 코드 업데이트가 필요한 경우 마이그레이션 계획 수립
5. **문서화**: 이 헌법 및 관련 템플릿 업데이트

### 버전 의미 체계

- **MAJOR** (X.0.0): 원칙 제거, 재정의 또는 하위 호환되지 않는 거버넌스 변경
- **MINOR** (0.X.0): 새로운 원칙 추가 또는 기존 원칙의 실질적인 확장
- **PATCH** (0.0.X): 명확화, 문구 개선, 비의미적 업데이트

### 준수 사항

- **모든 코드 변경**은 핵심 원칙에 부합해야 함
- **풀 리퀘스트**는 아키텍처 결정 시 해당 원칙을 참조해야 함
- **복잡도 예외**: 원칙 위반은 plan.md의 복잡도 추적 섹션에 정당화와 함께 문서화되어야 함
- **리뷰 프로세스**: 리뷰어는 헌법 준수 여부를 확인해야 함

**버전**: 1.0.1 | **비준일**: 2026-01-08 | **최종 개정일**: 2026-01-08
